import graphviz

from library.tools import nodes_list_from_tree, breadcrumb_dict


def names_from_list(node_list: list, layer: str = '') -> set:
    """
    Generating the set of node names used in the list of graph nodes
    :param node_list: the list of graph nodes generated by function list_from_tree() from the graph tree
    :param layer: optional parametr to limit the set to the names of the one layer
    :return: The set of the used names
    """
    names_set = set()
    for element in node_list:
        try:
            if layer:
                if layer == element['Layer']:
                    names_set.add(element['Name'])
            else:
                names_set.add(element['Name'])
        except:
            pass
    return names_set


def ids_from_list(node_list: list, layer: str ='') -> set:
    """
    Generating the set of node names used in the list of graph nodes and the instruction list and preconditions list added as the last elements of the ist if exist
    :param node_list: the list of graph nodes generated by function list_from_tree() from the graph tree
    :param layer: optional parametr to limit the set to the ids of the one layer
    :return: The set of the used ids
    """
    ids_set = set()
    for element in node_list:
        try:
            if layer:
                if layer == element['Layer']:
                    ids_set.add(element['Id'])
            else:
                ids_set.add(element['Id'])
        except:
            pass
    return ids_set


def attributes_from_list(node_list: list, layer: str ='') -> set:
    """
    Generating the set of node attributes used in the list of graph nodes
    :param node_list: the list of graph nodes generated by function list_from_tree() from the graph tree
    :param layer: optional parametr to limit the set to the ids of the one layer
    :return: The set of the used attributes
    """
    attributes_set = set()
    for element in node_list:
        try:
            if layer:
                if layer == element['Layer']:
                    attributes_set.update(element['Attributes'].keys())
            else:
                attributes_set.update(element['Attributes'].keys())
        except:
            pass
    return attributes_set


def param_nodes_from_list(node_list: list) -> set:
    """
    Generating the set of instruction parameters: "node(s)" used in the list of graph nodes
    :param node_list: the list of graph nodes generated by function list_from_tree() from the graph tree
    :return: The set of the used values of the parameters "Node" and "Nodes"
    """
    param_nodes_set = set()
    for element in node_list:
        try:
            for instruction in element['Instructions']:
                param_nodes_set.add(instruction['Node'])
                param_nodes_set.add(instruction['Nodes'])
        except:
            pass
    return param_nodes_set


def param_cond_from_list(node_list: list) -> set:
    """
    Generating the set of instruction parameters: "Cond" used in the list of graph nodes
    :param node_list: the list of graph nodes generated by function list_from_tree() from the graph tree
    :return: The set of the used values of the parameters "Cond"
    """
    param_cond_set = set()
    for element in node_list:
        try:
            for precondition in element['Preconditions']:
                param_cond_set.add(precondition['Cond'])
        except:
            pass
    return param_cond_set


def multireferences_from_list(node_list: list) -> set:
    """
    Generating the set of (multi)references used in the instructions added to the list of graph nodes
    :param node_list: the list of graph nodes generated by function list_from_tree() from the graph tree
    :return: The set of the used (multi)references
    """
    multireference_set = set()
    for instruction in node_list[-1]['Instructions']:
        try:
            multireference_set.add(instruction['Node'])
        except:
            pass
        try:
            multireference_set.add(instruction['Nodes'])
        except:
            pass
    return multireference_set


def destinations_from_list(node_list: list) -> set:
    """
    Generating the set of destinations used in the list of graph nodes
    :param node_list: the list of graph nodes generated by function list_from_tree() from the graph tree
    :return: The set of the used destinations
    """
    destinations_set = set()
    for element in node_list:
        try:
            for destination in element['Connections']:
                destinations_set.add(destination['Destination'])
        except:
            pass
    # qdebug('Zbiór połączonych lokacji:', destinations_set)
    return destinations_set


def expr_from_list(node_list: list) -> set:
    """
    Generating the set of expressions used in the instructions added to the list of graph nodes
    :param node_list: the list of graph nodes generated by function list_from_tree() from the graph tree
    :return: The set of the used (multi)references
    """
    expr_set = set()
    for instruction in node_list[-1]['Instructions']:
        try:
            expr_set.add(instruction['Expr'])
        except:
            pass

    return expr_set


def world_to_string(variant, world):
    return
    # w_sheafs = []
    # serialised_variant = []
    # for ls_id, w_id in variant:
    #     ls_node = ctypes.cast(ls_id, ctypes.py_object).value
    #     w_node = ctypes.cast(ls_id, ctypes.py_object).value
    #     if w_node in world:
    #         w_root = w_node
    #         sw_node = deepcopy(w_node)
    #         w_sheafs.append(sw_node)
    #     else:
    #         w_node_path = breadcrumb_pointer(w_root, pointer=w_node)
    #
    #
    #         if 'Connections' in sw_node:
    #             del(sw_node['Connections'])
    #
    #         w_sheafs.append(sw_node)
    #
    #
    #     ls_node.get('Id',ls_node.get('Name'))
    #
    #     w_node_path = breadcrumb_pointer(w_root, pointer=w_node)
    #     for


# def get_production_tree(mission_name, *jsons, directory_path='../visualisation/out_hierarchy'):
#     node_attributes = {
#         'shape': 'box',
#         'style': 'filled',
#         # 'fillcolor': 'white',
#         # 'width': '10'
#         # 'color': background_colors[parent_key],
#     }
#     graph = graphviz.Digraph(engine='dot')
#     graph.attr(overlap='false')
#     graph.attr(splines='polyline')
#     graph.attr(dpi='150')
#     graph.attr(ratio='fill')
#     graph.attr(labelloc='t')
#     graph.attr(rankdir='LR')
#     graph.attr(shape='box')
#
#     graph.node('root')
#     production_tree = {'root': {}}
#     production_missing = {'missing': {}}
#     production_titles = []
#     production_list = []
#
#     jsons_all = []
#     for json_given in jsons:
#         jsons_all.extend(json_given)
#
#
#     for production in jsons_all:
#         if production['Title'] in production_titles:
#             if production in production_list:
#                 print(f"Dwie identyczne produkcje o tych samych nazwach: {production['Title']}")
#                 continue
#             else:
#                 print(f"Dwie różne produkcje o tych samych nazwach: {production['Title']}")
#             return False
#         else:
#             production_titles.append(production['Title'])
#             production_list.append(production)
#
#
#         nodes_list = nodes_list_from_tree(production['LSide'])
#         gen_locations = False
#         gen_others = False
#         for node in nodes_list:
#             if node['layer'] == "Locations" and not node['node'].get('Name'):
#                 gen_locations = True
#             if node['layer'] != "Locations" and not node['node'].get('Name'):
#                 gen_others = True
#         if gen_others:
#             fc = 'white'
#         elif gen_locations:
#             fc = '#e8f2e8'
#         else:
#             fc = '#D5E8D4'
#
#         if production['TitleGeneric'] == "":
#             production_tree['root'][production['Title']] = {}
#             graph.node(production['Title'].split(" / ")[0], **node_attributes, fillcolor=fc)
#             graph.edge('root', production['Title'].split(" / ")[0])
#         else:
#             try:
#                 breadcrumb_dict(production_tree, production['TitleGeneric'])[production['Title']] = {}
#                 graph.node(production['Title'].split(" / ")[0], **node_attributes, fillcolor=fc)
#                 graph.edge(production['TitleGeneric'].split(" / ")[0], production['Title'].split(" / ")[0])
#             except:
#                 try:
#                     breadcrumb_dict(production_missing, production['TitleGeneric'])[production['Title']] = {}
#                     graph.node(production['Title'].split(" / ")[0], **node_attributes, fillcolor=fc)
#                     graph.edge(production['TitleGeneric'].split(" / ")[0], production['Title'].split(" / ")[0])
#                 except:
#                     production_missing[production['TitleGeneric']] = {production['Title']: {}}
#                     graph.node(production['Title'].split(" / ")[0], **node_attributes, fillcolor=fc)
#                     graph.edge('missing', production['Title'].split(" / ")[0])
#
#         # node_attributes = {
#         #     'shape': 'box',
#         #     'style': 'filled',
#         #     'fillcolor': '#D5E8D4',
#         #     # 'width': '10'
#         #     # 'color': background_colors[parent_key],
#         # }
#         # edge_attributes = {
#         #
#         # }
#         #
#
#
#     if len(production_missing['missing']):
#         graph.node('start')
#         graph.edge('start', 'root')
#         graph.node('missing', fillcolor='#F8CECC', color='red', style='filled')
#         graph.edge('start', 'missing')
#
#     graph.render(format='png', filename=f'{mission_name}',
#                  directory=directory_path, cleanup=True)
#
#     return
#
#
# def get_production_tree_very_old (mission_name, json_given1, json_given2):
#     node_attributes = {
#         'shape': 'box',
#         'style': 'filled',
#         'fillcolor': 'white',
#         # 'width': '10'
#         # 'color': background_colors[parent_key],
#     }
#     graph = graphviz.Digraph(engine='dot')
#     graph.attr(overlap='false')
#     graph.attr(splines='polyline')
#     graph.attr(dpi='150')
#     graph.attr(ratio='fill')
#     graph.attr(labelloc='t')
#     graph.attr(rankdir='LR')
#     graph.attr(shape='box')
#
#
#     graph.node('root')
#     production_tree = {'root': {}}
#     production_missing = {'missing': {}}
#     for production in json_given1:
#         if production['TitleGeneric'] == "":
#             production_tree['root'][production['Title']] = {}
#             graph.node(production['Title'], **node_attributes)
#             graph.edge('root', production['Title'])
#         else:
#             try:
#                 breadcrumb_dict(production_tree, production['TitleGeneric'])[production['Title']] = {}
#                 graph.node(production['Title'], **node_attributes)
#                 graph.edge(production['TitleGeneric'], production['Title'])
#             except:
#                 try:
#                     breadcrumb_dict(production_missing, production['TitleGeneric'])[production['Title']] = {}
#                     graph.node(production['Title'], **node_attributes)
#                     graph.edge(production['TitleGeneric'], production['Title'])
#                 except:
#                     production_missing[production['TitleGeneric']] = {production['Title']: {}}
#                     graph.node(production['Title'], **node_attributes)
#                     graph.edge('missing', production['Title'])
#
#     node_attributes = {
#         'shape': 'box',
#         'style': 'filled',
#         'fillcolor': '#D5E8D4',
#         # 'width': '10'
#         # 'color': background_colors[parent_key],
#     }
#     edge_attributes = {
#
#     }
#
#     for production in json_given2:
#         if production['TitleGeneric'] == "":
#             production_tree['root'][production['Title']] = {}
#             graph.node(production['Title'], **node_attributes)
#             graph.edge('root', production['Title'], **edge_attributes)
#         else:
#             try:
#                 breadcrumb_dict(production_tree, production['TitleGeneric'])[production['Title']] = {}
#                 graph.node(production['Title'], **node_attributes)
#                 graph.edge(production['TitleGeneric'], production['Title'], **edge_attributes)
#             except:
#                 try:
#                     breadcrumb_dict(production_missing, production['TitleGeneric'])[production['Title']] = {}
#                     graph.node(production['Title'], **node_attributes)
#                     graph.edge(production['TitleGeneric'], production['Title'], **edge_attributes)
#                 except:
#                     production_missing['missing'][production['TitleGeneric']] = {production['Title']: {}}
#                     graph.node(production['Title'], **node_attributes)
#                     graph.edge('missing', production['Title'], **edge_attributes)
#
#     if len(production_missing['missing']):
#         graph.node('start')
#         graph.edge('start', 'root')
#         graph.node('missing',  fillcolor='#F8CECC', color='red', style='filled')
#         graph.edge('start', 'missing')
#
#     graph.render(format='png', filename=f'{mission_name}',
#            directory=f'../visualisation/out_hierarchy', cleanup=True)
#
#     return
#
#
# def get_production_tree2(mission_name, *jsons):
#     node_attributes = {
#         'shape': 'box',
#         'style': 'filled',
#         # 'fillcolor': 'white',
#         # 'width': '10'
#         # 'color': background_colors[parent_key],
#     }
#     graph = graphviz.Digraph(engine='dot')
#     graph.attr(overlap='false')
#     graph.attr(splines='polyline')
#     graph.attr(dpi='150')
#     graph.attr(ratio='fill')
#     graph.attr(labelloc='t')
#     graph.attr(rankdir='LR')
#     graph.attr(shape='box')
#
#     graph.node('root')
#     production_tree = {'root': {}}
#     production_missing = {'missing': {}}
#     production_dict = {}
#     production_list = []
#     production_titles = []
#
#     jsons_all = []
#     for json_given in jsons:
#         jsons_all.extend(json_given)
#
#     for production in jsons_all:
#         if production['Title'] in production_titles:
#             if production in production_list:
#                 print(f"Dwie identyczne produkcje o tych samych nazwach: {production['Title']}")
#                 continue
#             else:
#                 print(f"Dwie różne produkcje o tych samych nazwach: {production['Title']}")
#             return False
#         else:
#             production_dict[production['Title']] = production
#             production_dict[production['Title']]['overridden_by_children'] = False
#             # production_dict[production['Title']]['tree_node'] =
#             production_list.append(production)
#             production_titles.append(production['Title'])
#
#     roots = set()
#     mapping = {}
#     for production in jsons_all:  # parent, child in data:
#         childitem = mapping.get(production['Title'], None)
#         if childitem is None:
#             childitem = {}
#             mapping[production['Title']] = childitem
#             production_dict[production['Title']]['children'] = childitem
#             # production_dict[production['Title']]['override'] = False
#
#
#         else:
#             roots.discard(production['Title'])
#         parentitem = mapping.get(production['TitleGeneric'], None)
#         if parentitem is None:
#             mapping[production['TitleGeneric']] = {production['Title']: childitem}
#
#             roots.add(production['TitleGeneric'])
#         else:
#             parentitem[production['Title']] = childitem
#
#     tree = {id: mapping[id] for id in roots}
#
#     # print("aaa", tree)
#
#     for production in jsons_all:
#         # if production['Title'] in production_titles:
#         #     if production in production_list:
#         #         print(f"Dwie identyczne produkcje o tych samych nazwach: {production['Title']}")
#         #         continue
#         #     else:
#         #         print(f"Dwie różne produkcje o tych samych nazwach: {production['Title']}")
#         #     return False
#         # else:
#         #     production_dict[production['Title']] = production
#         #     # production_dict[production['Title']]['tree_node'] =
#         #     production_list.append(production)
#         #     production_titles.append(production['Title'])
#
#
#         nodes_list = nodes_list_from_tree(production['LSide'])
#         gen_locations = False
#         gen_others = False
#         for node in nodes_list:
#             if node['layer'] == "Locations" and not node['node'].get('Name'):
#                 gen_locations = True
#             if node['layer'] != "Locations" and not node['node'].get('Name'):
#                 gen_others = True
#         if gen_others:
#             fc = 'white'
#         elif gen_locations:
#             fc = '#e8f2e8'
#         else:
#             fc = '#D5E8D4'
#
#         if production['TitleGeneric'] == "":
#             production_tree['root'][production['Title']] = production
#             graph.node(production['Title'].split(" / ")[0], **node_attributes, fillcolor=fc)
#             graph.edge('root', production['Title'].split(" / ")[0])
#         # else:
#         #     if production['TitleGeneric'] in production_dict:
#         #
#         #
#         #
#         #
#         #
#         #
#         #
#         #     try:
#         #         breadcrumb_dict(production_tree, production['TitleGeneric'])[production['Title']] = {}
#         #         graph.node(production['Title'].split(" / ")[0], **node_attributes, fillcolor=fc)
#         #         graph.edge(production['TitleGeneric'].split(" / ")[0], production['Title'].split(" / ")[0])
#         #     except:
#         #         try:
#         #             breadcrumb_dict(production_missing, production['TitleGeneric'])[production['Title']] = {}
#         #             graph.node(production['Title'].split(" / ")[0], **node_attributes, fillcolor=fc)
#         #             graph.edge(production['TitleGeneric'].split(" / ")[0], production['Title'].split(" / ")[0])
#         #         except:
#         #             production_missing[production['TitleGeneric']] = {production['Title']: {}}
#         #             graph.node(production['Title'].split(" / ")[0], **node_attributes, fillcolor=fc)
#         #             graph.edge('missing', production['Title'].split(" / ")[0])
#
#         # node_attributes = {
#         #     'shape': 'box',
#         #     'style': 'filled',
#         #     'fillcolor': '#D5E8D4',
#         #     # 'width': '10'
#         #     # 'color': background_colors[parent_key],
#         # }
#         # edge_attributes = {
#         #
#         # }
#         #
#
#
#     if len(production_missing['missing']):
#         graph.node('start')
#         graph.edge('start', 'root')
#         graph.node('missing', fillcolor='#F8CECC', color='red', style='filled')
#         graph.edge('start', 'missing')
#
#     graph.render(format='png', filename=f'{mission_name}',
#                  directory=f'../visualisation/out_hierarchy', cleanup=True)
#
#     for prod_name, prod in production_dict.items():
#         for child in prod['children']:
#             if production_dict[child].get('Override') == 1:
#                 prod['overridden_by_children'] = True
#             break
#
#     return tree[''], production_dict